# 排序

常见排序算法：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序

| 排序算法     | 时间复杂度    | 是否基于比较 |
|:---------|:---------|:-------|
| 冒泡、插入、选择 | O(n^2)   | 是      |
| 快排、归并    | O(nlogn) | 是      |
| 桶计算、基数   | O(n)     | 否      |

### 排序算法分析
1. 执行效率分析
   1. 最好情况、最坏情况、平均情况时间复杂度
   2. 时间复杂度的系数、常数 、低阶
   3. 比较次数和交换（或移动）次数
2. 内存消耗：空间复杂度，原地排序
3. 排序稳定性：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。

## 冒泡排序（Bubble Sort）

`冒泡排序`只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。
如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。

```go
func BubbleSort(a []int) []int {
	length := len(a)
	flag := false
	for i := 0; i < length; i++ {
		for j := length - 1; j > i; j-- {
			if a[j] < a[j-1] {
				a[j], a[j-1] = a[j-1], a[j]
				flag = true
			}
		}
		
		if !flag {
			break
		}
	}

	return a
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1) 属于原地排序算法
- 排序稳定性：当相邻的两个元素相等时不做交换，即可保证相等的元素不会改变顺序。属于稳定的排序算法。

## 插入排序（Insertion Sort）

首先，我们将数组中的数据分为两个区间，`已排序区间`和`未排序区间`。 初始已排序区间只有一个元素，就是数组的第一个元素。
插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
重复这个过程，直到未排序区间中元素为空，算法结束。

```go
func InsertionSort(a []int) []int {
	length := len(a)
	for i := 1; i < length; i++ {
		j := i - 1
		value := a[i]
		for ; j >= 0; j-- {
			if a[j] > value {
				a[j+1] = a[j]
			} else {
				break
			}
		}
		a[j+1] = value
	}
	return a
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1) 属于原地排序算法
- 排序稳定性：当出现相等的元素时，直接插在已排序元素的后面，保持原有的前后顺序不变。属于稳定的排序算法。

### 优化思路

拆半插入

### 插入排序比冒泡排序更受欢迎

两者的交换次数均固定，但是冒泡排序需要更多的数据移动操作。


## 选择排序（Selection Sort）

选择排序算法的实现思路与插入排序类似，也分`已排序区间`和`未排序区间`。
但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

```go
func SelectionSort(a []int) []int {
	length := len(a)
	
	for i := 0; i < length-1; i++ {
		idx := i
		for j := i + 1; j < length; j++ {
			if a[j] < a[idx] {
				idx = j
			}
		}
		a[i], a[idx] = a[idx], a[i]
	}

	return a
}
```

- 时间复杂度：O(n^2)
- 空间复杂度：O(1) 属于原地排序算法
- 排序稳定性：不稳定。比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。


## 归并排序（Merge Sort）

如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。

归并排序使用的是`分治思想`。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。

- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)，归并排序不是原地排序，这也是它不如快排应用广范的主要原因。
- 排序稳定性：稳定。归并排序的稳定性关键看merge函数。


## 快速排序（Quick Sort）

如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，
将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。
经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，
前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。

- 时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 排序稳定性：不稳定