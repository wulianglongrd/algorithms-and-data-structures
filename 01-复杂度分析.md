## 算法复杂度分析

 ### 为什么需要复杂度分析

- 测试结果非常依赖测试环境
- 测试结果受数据规模的影响很大

### 大O表示法

``` T(n) = O(f(n)) ```
大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。
所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

### 时间复杂度分析

1. 只关注循环执行次数最多的一段代码

`T(n) = 2 + 2*n`

所以时间复杂度为 n

```java
  int cal(int n) {
    int sum = 0;
    int i = 1;
    for (; i <= n; ++i) { // n次
      sum = sum + i;      // n次
    }
    return sum;
  }
```

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

`T(n) = 100 + n + n*n `

取其中最大的量级，所以，整段代码的时间复杂度为 n*n。

也就是说：总的时间复杂度就等于量级最大的那段代码的时间复杂度，抽象成公式为 <br/>
如果： T1(n) = O(f(n)) <br/>
      T2(n) = O(g(n)) <br/>
那么： T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n))) <br/>

```java
  int cal(int n) {
    // 常量的执行时间，与n的规模无关。
    int sum_1 = 0;
    int p = 1;
    for (; p < 100; ++p) {
      sum_1 = sum_1 + p;
    }

    // n
    int sum_2 = 0;
    int q = 1;
    for (; q < n; ++q) {
      sum_2 = sum_2 + q;
    }

    // n*n
    int sum_3 = 0;
    int i = 1;
    int j = 1;
    for (; i <= n; ++i) {
      j = 1;
      for (; j <= n; ++j) {
        sum_3 = sum_3 +  i * j;
      }
    }

    return sum_1 + sum_2 + sum_3;
  }
```

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度和乘积（嵌套循环）

如果： T1(n) = O(f(n)), T2(n) = O(g(n)) <br/>
那么： T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))

```java
  // n * n
  int cal(int n) {
    int ret = 0; 
    int i = 1;
    for (; i < n; ++i) {
      ret = ret + f(i);
    } 
  } 
 
  // n
  int f(int n) {
    int sum = 0;
    int i = 1;
    for (; i < n; ++i) {
      sum = sum + i;
    } 

    return sum;
  }
```